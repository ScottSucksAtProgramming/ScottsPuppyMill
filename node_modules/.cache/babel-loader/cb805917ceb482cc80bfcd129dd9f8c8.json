{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { multicall as multicall1, multicall2, useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { useBlockNumbers } from '../../blockNumber/blockNumbers';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer } from '../common';\nimport { getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function MultiChainStateProvider(_ref) {\n  let {\n    children,\n    multicallAddresses\n  } = _ref;\n  const {\n    multicallVersion\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const {\n    reportError\n  } = useNetwork();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const multicall = multicallVersion === 1 ? multicall1 : multicall2;\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]); // used for deep equality in hook dependencies\n\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls);\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n\n  function multicallForChain(chainId, provider) {\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n\n    const callsOnThisChain = uniqueCalls.filter(call => call.chainId === chainId);\n\n    if (callsOnThisChain.length === 0) {\n      return;\n    }\n\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls\n    });\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      multicallForChain(Number(_chainId), provider);\n    }\n  }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n} //# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"module"}