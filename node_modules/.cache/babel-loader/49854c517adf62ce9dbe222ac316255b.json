{"ast":null,"code":"import { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * @public\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(chainId, options);\n  const [events, setEvents] = useState(undefined);\n  const send = useCallback(async function () {\n    const contractWithSigner = connectContractToSigner(contract, options, library);\n    const receipt = await promiseTransaction(contractWithSigner[functionName](...arguments));\n\n    if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n      const events = receipt.logs.reduce((accumulatedLogs, log) => {\n        try {\n          return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n        } catch (_err) {\n          return accumulatedLogs;\n        }\n      }, []);\n      setEvents(events);\n    }\n  }, [contract, functionName, options, library]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n} //# sourceMappingURL=useContractFunction.js.map","map":null,"metadata":{},"sourceType":"module"}